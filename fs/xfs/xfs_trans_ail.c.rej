--- fs/xfs/xfs_trans_ail.c
+++ fs/xfs/xfs_trans_ail.c
@@ -163,11 +165,17 @@
 }
 
 /*
- * The cursor keeps track of where our current traversal is up to by tracking
- * the next item in the list for us. However, for this to be safe, removing an
- * object from the AIL needs to invalidate any cursor that points to it. hence
- * the traversal cursor needs to be linked to the struct xfs_ail so that
- * deletion can search all the active cursors for invalidation.
+ * AIL traversal cursor initialisation.
+ *
+ * The cursor keeps track of where our current traversal is up
+ * to by tracking the next Æ£tem in the list for us. However, for
+ * this to be safe, removing an object from the AIL needs to invalidate
+ * any cursor that points to it. hence the traversal cursor needs to
+ * be linked to the struct xfs_ail so that deletion can search all the
+ * active cursors for invalidation.
+ *
+ * We don't link the push cursor because it is embedded in the struct
+ * xfs_ail and hence easily findable.
  */
 STATIC void
 xfs_trans_ail_cursor_init(
@@ -175,12 +183,31 @@
 	struct xfs_ail_cursor	*cur)
 {
 	cur->item = NULL;
-	list_add_tail(&cur->list, &ailp->xa_cursors);
+	if (cur == &ailp->xa_cursors)
+		return;
+
+	cur->next = ailp->xa_cursors.next;
+	ailp->xa_cursors.next = cur;
+}
+
+/*
+ * Set the cursor to the next item, because when we look
+ * up the cursor the current item may have been freed.
+ */
+STATIC void
+xfs_trans_ail_cursor_set(
+	struct xfs_ail		*ailp,
+	struct xfs_ail_cursor	*cur,
+	struct xfs_log_item	*lip)
+{
+	if (lip)
+		cur->item = xfs_ail_next(ailp, lip);
 }
 
 /*
- * Get the next item in the traversal and advance the cursor.  If the cursor
- * was invalidated (indicated by a lip of 1), restart the traversal.
+ * Get the next item in the traversal and advance the cursor.
+ * If the cursor was invalidated (inidicated by a lip of 1),
+ * restart the traversal.
  */
 struct xfs_log_item *
 xfs_trans_ail_cursor_next(
@@ -191,31 +218,45 @@
 
 	if ((__psint_t)lip & 1)
 		lip = xfs_ail_min(ailp);
-	if (lip)
-		cur->item = xfs_ail_next(ailp, lip);
+	xfs_trans_ail_cursor_set(ailp, cur, lip);
 	return lip;
 }
 
 /*
- * When the traversal is complete, we need to remove the cursor from the list
- * of traversing cursors.
+ * Now that the traversal is complete, we need to remove the cursor
+ * from the list of traversing cursors. Avoid removing the embedded
+ * push cursor, but use the fact it is always present to make the
+ * list deletion simple.
  */
 void
 xfs_trans_ail_cursor_done(
 	struct xfs_ail		*ailp,
-	struct xfs_ail_cursor	*cur)
+	struct xfs_ail_cursor	*done)
 {
-	cur->item = NULL;
-	list_del_init(&cur->list);
+	struct xfs_ail_cursor	*prev = NULL;
+	struct xfs_ail_cursor	*cur;
+
+	done->item = NULL;
+	if (done == &ailp->xa_cursors)
+		return;
+	prev = &ailp->xa_cursors;
+	for (cur = prev->next; cur; prev = cur, cur = prev->next) {
+		if (cur == done) {
+			prev->next = cur->next;
+			break;
+		}
+	}
+	ASSERT(cur);
 }
 
 /*
- * Invalidate any cursor that is pointing to this item. This is called when an
- * item is removed from the AIL. Any cursor pointing to this object is now
- * invalid and the traversal needs to be terminated so it doesn't reference a
- * freed object. We set the low bit of the cursor item pointer so we can
- * distinguish between an invalidation and the end of the list when getting the
- * next item from the cursor.
+ * Invalidate any cursor that is pointing to this item. This is
+ * called when an item is removed from the AIL. Any cursor pointing
+ * to this object is now invalid and the traversal needs to be
+ * terminated so it doesn't reference a freed object. We set the
+ * cursor item to a value of 1 so we can distinguish between an
+ * invalidation and the end of the list when getting the next item
+ * from the cursor.
  */
 STATIC void
 xfs_trans_ail_cursor_clear(
@@ -224,7 +265,8 @@
 {
 	struct xfs_ail_cursor	*cur;
 
-	list_for_each_entry(cur, &ailp->xa_cursors, list) {
+	/* need to search all cursors */
+	for (cur = &ailp->xa_cursors; cur; cur = cur->next) {
 		if (cur->item == lip)
 			cur->item = (struct xfs_log_item *)
 					((__psint_t)cur->item | 1);
@@ -232,10 +274,9 @@
 }
 
 /*
- * Find the first item in the AIL with the given @lsn by searching in ascending
- * LSN order and initialise the cursor to point to the next item for a
- * ascending traversal.  Pass a @lsn of zero to initialise the cursor to the
- * first item in the AIL. Returns NULL if the list is empty.
+ * Return the item in the AIL with the current lsn.
+ * Return the current tree generation number for use
+ * in calls to xfs_trans_next_ail().
  */
 xfs_log_item_t *
 xfs_trans_ail_cursor_first(
@@ -246,101 +287,46 @@
 	xfs_log_item_t		*lip;
 
 	xfs_trans_ail_cursor_init(ailp, cur);
-
-	if (lsn == 0) {
-		lip = xfs_ail_min(ailp);
+	lip = xfs_ail_min(ailp);
+	if (lsn == 0)
 		goto out;
-	}
 
 	list_for_each_entry(lip, &ailp->xa_ail, li_ail) {
 		if (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)
 			goto out;
 	}
-	return NULL;
-
+	lip = NULL;
 out:
-	if (lip)
-		cur->item = xfs_ail_next(ailp, lip);
+	xfs_trans_ail_cursor_set(ailp, cur, lip);
 	return lip;
 }
 
-static struct xfs_log_item *
-__xfs_trans_ail_cursor_last(
-	struct xfs_ail		*ailp,
-	xfs_lsn_t		lsn)
-{
-	xfs_log_item_t		*lip;
-
-	list_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {
-		if (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)
-			return lip;
-	}
-	return NULL;
-}
-
-/*
- * Find the last item in the AIL with the given @lsn by searching in descending
- * LSN order and initialise the cursor to point to that item.  If there is no
- * item with the value of @lsn, then it sets the cursor to the last item with an
- * LSN lower than @lsn.  Returns NULL if the list is empty.
- */
-struct xfs_log_item *
-xfs_trans_ail_cursor_last(
-	struct xfs_ail		*ailp,
-	struct xfs_ail_cursor	*cur,
-	xfs_lsn_t		lsn)
-{
-	xfs_trans_ail_cursor_init(ailp, cur);
-	cur->item = __xfs_trans_ail_cursor_last(ailp, lsn);
-	return cur->item;
-}
-
 /*
- * Splice the log item list into the AIL at the given LSN. We splice to the
- * tail of the given LSN to maintain insert order for push traversals. The
- * cursor is optional, allowing repeated updates to the same LSN to avoid
- * repeated traversals.  This should not be called with an empty list.
+ * splice the log item list into the AIL at the given LSN.
  */
 static void
 xfs_ail_splice(
-	struct xfs_ail		*ailp,
-	struct xfs_ail_cursor	*cur,
-	struct list_head	*list,
-	xfs_lsn_t		lsn)
+	struct xfs_ail  *ailp,
+	struct list_head *list,
+	xfs_lsn_t       lsn)
 {
-	struct xfs_log_item	*lip;
+	xfs_log_item_t  *next_lip;
 
-	ASSERT(!list_empty(list));
+	/* If the list is empty, just insert the item.  */
+	if (list_empty(&ailp->xa_ail)) {
+		list_splice(list, &ailp->xa_ail);
+		return;
+	}
 
-	/*
-	 * Use the cursor to determine the insertion point if one is
-	 * provided.  If not, or if the one we got is not valid,
-	 * find the place in the AIL where the items belong.
-	 */
-	lip = cur ? cur->item : NULL;
-	if (!lip || (__psint_t) lip & 1)
-		lip = __xfs_trans_ail_cursor_last(ailp, lsn);
+	list_for_each_entry_reverse(next_lip, &ailp->xa_ail, li_ail) {
+		if (XFS_LSN_CMP(next_lip->li_lsn, lsn) <= 0)
+			break;
+	}
 
-	/*
-	 * If a cursor is provided, we know we're processing the AIL
-	 * in lsn order, and future items to be spliced in will
-	 * follow the last one being inserted now.  Update the
-	 * cursor to point to that last item, now while we have a
-	 * reliable pointer to it.
-	 */
-	if (cur)
-		cur->item = list_entry(list->prev, struct xfs_log_item, li_ail);
+	ASSERT(&next_lip->li_ail == &ailp->xa_ail ||
+	       XFS_LSN_CMP(next_lip->li_lsn, lsn) <= 0);
 
-	/*
-	 * Finally perform the splice.  Unless the AIL was empty,
-	 * lip points to the item in the AIL _after_ which the new
-	 * items should go.  If lip is null the AIL was empty, so
-	 * the new items go at the head of the AIL.
-	 */
-	if (lip)
-		list_splice(list, &lip->li_ail);
-	else
-		list_splice(list, &ailp->xa_ail);
+	list_splice_init(list, &next_lip->li_ail);
 }
 
 /*
@@ -356,12 +342,18 @@
 	xfs_trans_ail_cursor_clear(ailp, lip);
 }
 
-static long
-xfsaild_push(
-	struct xfs_ail		*ailp)
+/*
+ * xfs_ail_worker does the work of pushing on the AIL. It will requeue itself
+ * to run at a later time if there is more work to do to complete the push.
+ */
+STATIC void
+xfs_ail_worker(
+	struct work_struct	*work)
 {
+	struct xfs_ail		*ailp = container_of(to_delayed_work(work),
+					struct xfs_ail, xa_work);
 	xfs_mount_t		*mp = ailp->xa_mount;
-	struct xfs_ail_cursor	cur;
+	struct xfs_ail_cursor	*cur = &ailp->xa_cursors;
 	xfs_log_item_t		*lip;
 	xfs_lsn_t		lsn;
 	xfs_lsn_t		target;
@@ -373,12 +365,13 @@
 
 	spin_lock(&ailp->xa_lock);
 	target = ailp->xa_target;
-	lip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);
+	xfs_trans_ail_cursor_init(ailp, cur);
+	lip = xfs_trans_ail_cursor_first(ailp, cur, ailp->xa_last_pushed_lsn);
 	if (!lip || XFS_FORCED_SHUTDOWN(mp)) {
 		/*
 		 * AIL is empty or our push has reached the end.
 		 */
-		xfs_trans_ail_cursor_done(ailp, &cur);
+		xfs_trans_ail_cursor_done(ailp, cur);
 		spin_unlock(&ailp->xa_lock);
 		goto out_done;
 	}
@@ -466,12 +455,12 @@
 		if (stuck > 100)
 			break;
 
-		lip = xfs_trans_ail_cursor_next(ailp, &cur);
+		lip = xfs_trans_ail_cursor_next(ailp, cur);
 		if (lip == NULL)
 			break;
 		lsn = lip->li_lsn;
 	}
-	xfs_trans_ail_cursor_done(ailp, &cur);
+	xfs_trans_ail_cursor_done(ailp, cur);
 	spin_unlock(&ailp->xa_lock);
 
 	if (flush_log) {
@@ -664,7 +644,6 @@
 	int			i;
 	LIST_HEAD(tmp);
 
-	ASSERT(nr_items > 0);		/* Not required, but true. */
 	mlip = xfs_ail_min(ailp);
 
 	for (i = 0; i < nr_items; i++) {
@@ -684,8 +663,7 @@
 		list_add(&lip->li_ail, &tmp);
 	}
 
-	if (!list_empty(&tmp))
-		xfs_ail_splice(ailp, cur, &tmp, lsn);
+	xfs_ail_splice(ailp, &tmp, lsn);
 
 	if (!mlip_changed) {
 		spin_unlock(&ailp->xa_lock);
@@ -804,20 +782,10 @@
 
 	ailp->xa_mount = mp;
 	INIT_LIST_HEAD(&ailp->xa_ail);
-	INIT_LIST_HEAD(&ailp->xa_cursors);
 	spin_lock_init(&ailp->xa_lock);
-
-	ailp->xa_task = kthread_run(xfsaild, ailp, "xfsaild/%s",
-			ailp->xa_mount->m_fsname);
-	if (IS_ERR(ailp->xa_task))
-		goto out_free_ailp;
-
+	INIT_DELAYED_WORK(&ailp->xa_work, xfs_ail_worker);
 	mp->m_ail = ailp;
 	return 0;
-
-out_free_ailp:
-	kmem_free(ailp);
-	return ENOMEM;
 }
 
 void
