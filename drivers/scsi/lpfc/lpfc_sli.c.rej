--- drivers/scsi/lpfc/lpfc_sli.c
+++ drivers/scsi/lpfc/lpfc_sli.c
@@ -4712,15 +4710,10 @@
  * lpfc_sli4_get_avail_extnt_rsrc - Get available resource extent count.
  * @phba: Pointer to HBA context object.
  * @type: The resource extent type.
- * @extnt_count: buffer to hold port available extent count.
- * @extnt_size: buffer to hold element count per extent.
  *
- * This function calls the port and retrievs the number of available
- * extents and their size for a particular extent type.
- *
- * Returns: 0 if successful.  Nonzero otherwise.
+ * This function allocates all SLI4 resource identifiers.
  **/
-int
+static int
 lpfc_sli4_get_avail_extnt_rsrc(struct lpfc_hba *phba, uint16_t type,
 			       uint16_t *extnt_count, uint16_t *extnt_size)
 {
@@ -4897,7 +4890,7 @@
 				     req_len, *emb);
 	if (alloc_len < req_len) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-			"2982 Allocated DMA memory size (x%x) is "
+			"9000 Allocated DMA memory size (x%x) is "
 			"less than the requested DMA memory "
 			"size (x%x)\n", alloc_len, req_len);
 		return -ENOMEM;
@@ -5511,154 +5504,6 @@
 }
 
 /**
- * lpfc_sli4_get_allocated_extnts - Get the port's allocated extents.
- * @phba: Pointer to HBA context object.
- * @type: The resource extent type.
- * @extnt_count: buffer to hold port extent count response
- * @extnt_size: buffer to hold port extent size response.
- *
- * This function calls the port to read the host allocated extents
- * for a particular type.
- **/
-int
-lpfc_sli4_get_allocated_extnts(struct lpfc_hba *phba, uint16_t type,
-			       uint16_t *extnt_cnt, uint16_t *extnt_size)
-{
-	bool emb;
-	int rc = 0;
-	uint16_t curr_blks = 0;
-	uint32_t req_len, emb_len;
-	uint32_t alloc_len, mbox_tmo;
-	struct list_head *blk_list_head;
-	struct lpfc_rsrc_blks *rsrc_blk;
-	LPFC_MBOXQ_t *mbox;
-	void *virtaddr = NULL;
-	struct lpfc_mbx_nembed_rsrc_extent *n_rsrc;
-	struct lpfc_mbx_alloc_rsrc_extents *rsrc_ext;
-	union  lpfc_sli4_cfg_shdr *shdr;
-
-	switch (type) {
-	case LPFC_RSC_TYPE_FCOE_VPI:
-		blk_list_head = &phba->lpfc_vpi_blk_list;
-		break;
-	case LPFC_RSC_TYPE_FCOE_XRI:
-		blk_list_head = &phba->sli4_hba.lpfc_xri_blk_list;
-		break;
-	case LPFC_RSC_TYPE_FCOE_VFI:
-		blk_list_head = &phba->sli4_hba.lpfc_vfi_blk_list;
-		break;
-	case LPFC_RSC_TYPE_FCOE_RPI:
-		blk_list_head = &phba->sli4_hba.lpfc_rpi_blk_list;
-		break;
-	default:
-		return -EIO;
-	}
-
-	/* Count the number of extents currently allocatd for this type. */
-	list_for_each_entry(rsrc_blk, blk_list_head, list) {
-		if (curr_blks == 0) {
-			/*
-			 * The GET_ALLOCATED mailbox does not return the size,
-			 * just the count.  The size should be just the size
-			 * stored in the current allocated block and all sizes
-			 * for an extent type are the same so set the return
-			 * value now.
-			 */
-			*extnt_size = rsrc_blk->rsrc_size;
-		}
-		curr_blks++;
-	}
-
-	/* Calculate the total requested length of the dma memory. */
-	req_len = curr_blks * sizeof(uint16_t);
-
-	/*
-	 * Calculate the size of an embedded mailbox.  The uint32_t
-	 * accounts for extents-specific word.
-	 */
-	emb_len = sizeof(MAILBOX_t) - sizeof(struct mbox_header) -
-		sizeof(uint32_t);
-
-	/*
-	 * Presume the allocation and response will fit into an embedded
-	 * mailbox.  If not true, reconfigure to a non-embedded mailbox.
-	 */
-	emb = LPFC_SLI4_MBX_EMBED;
-	req_len = emb_len;
-	if (req_len > emb_len) {
-		req_len = curr_blks * sizeof(uint16_t) +
-			sizeof(union lpfc_sli4_cfg_shdr) +
-			sizeof(uint32_t);
-		emb = LPFC_SLI4_MBX_NEMBED;
-	}
-
-	mbox = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
-	if (!mbox)
-		return -ENOMEM;
-	memset(mbox, 0, sizeof(LPFC_MBOXQ_t));
-
-	alloc_len = lpfc_sli4_config(phba, mbox, LPFC_MBOX_SUBSYSTEM_COMMON,
-				     LPFC_MBOX_OPCODE_GET_ALLOC_RSRC_EXTENT,
-				     req_len, emb);
-	if (alloc_len < req_len) {
-		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
-			"2983 Allocated DMA memory size (x%x) is "
-			"less than the requested DMA memory "
-			"size (x%x)\n", alloc_len, req_len);
-		rc = -ENOMEM;
-		goto err_exit;
-	}
-	rc = lpfc_sli4_mbox_rsrc_extent(phba, mbox, curr_blks, type, emb);
-	if (unlikely(rc)) {
-		rc = -EIO;
-		goto err_exit;
-	}
-
-	if (!phba->sli4_hba.intr_enable)
-		rc = lpfc_sli_issue_mbox(phba, mbox, MBX_POLL);
-	else {
-		mbox_tmo = lpfc_mbox_tmo_val(phba, MBX_SLI4_CONFIG);
-		rc = lpfc_sli_issue_mbox_wait(phba, mbox, mbox_tmo);
-	}
-
-	if (unlikely(rc)) {
-		rc = -EIO;
-		goto err_exit;
-	}
-
-	/*
-	 * Figure out where the response is located.  Then get local pointers
-	 * to the response data.  The port does not guarantee to respond to
-	 * all extents counts request so update the local variable with the
-	 * allocated count from the port.
-	 */
-	if (emb == LPFC_SLI4_MBX_EMBED) {
-		rsrc_ext = &mbox->u.mqe.un.alloc_rsrc_extents;
-		shdr = &rsrc_ext->header.cfg_shdr;
-		*extnt_cnt = bf_get(lpfc_mbx_rsrc_cnt, &rsrc_ext->u.rsp);
-	} else {
-		virtaddr = mbox->sge_array->addr[0];
-		n_rsrc = (struct lpfc_mbx_nembed_rsrc_extent *) virtaddr;
-		shdr = &n_rsrc->cfg_shdr;
-		*extnt_cnt = bf_get(lpfc_mbx_rsrc_cnt, n_rsrc);
-	}
-
-	if (bf_get(lpfc_mbox_hdr_status, &shdr->response)) {
-		lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_INIT,
-			"2984 Failed to read allocated resources "
-			"for type %d - Status 0x%x Add'l Status 0x%x.\n",
-			type,
-			bf_get(lpfc_mbox_hdr_status, &shdr->response),
-			bf_get(lpfc_mbox_hdr_add_status, &shdr->response));
-		rc = -EIO;
-		goto err_exit;
-	}
- err_exit:
-	lpfc_sli4_mbox_cmd_free(phba, mbox);
-	return rc;
-}
-
-/**
  * lpfc_sli4_hba_setup - SLI4 device intialization PCI function
  * @phba: Pointer to HBA context object.
  *
@@ -6787,9 +6631,6 @@
 	unsigned long iflags;
 	int rc;
 
-	/* dump from issue mailbox command if setup */
-	lpfc_idiag_mbxacc_dump_issue_mbox(phba, &mboxq->u.mb);
-
 	rc = lpfc_mbox_dev_check(phba);
 	if (unlikely(rc)) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,
@@ -14607,92 +14423,6 @@
 }
 
 /**
- * lpfc_check_next_fcf_pri
- * phba pointer to the lpfc_hba struct for this port.
- * This routine is called from the lpfc_sli4_fcf_rr_next_index_get
- * routine when the rr_bmask is empty. The FCF indecies are put into the
- * rr_bmask based on their priority level. Starting from the highest priority
- * to the lowest. The most likely FCF candidate will be in the highest
- * priority group. When this routine is called it searches the fcf_pri list for
- * next lowest priority group and repopulates the rr_bmask with only those
- * fcf_indexes.
- * returns:
- * 1=success 0=failure
- **/
-int
-lpfc_check_next_fcf_pri_level(struct lpfc_hba *phba)
-{
-	uint16_t next_fcf_pri;
-	uint16_t last_index;
-	struct lpfc_fcf_pri *fcf_pri;
-	int rc;
-	int ret = 0;
-
-	last_index = find_first_bit(phba->fcf.fcf_rr_bmask,
-			LPFC_SLI4_FCF_TBL_INDX_MAX);
-	lpfc_printf_log(phba, KERN_INFO, LOG_FIP,
-			"3060 Last IDX %d\n", last_index);
-	if (list_empty(&phba->fcf.fcf_pri_list)) {
-		lpfc_printf_log(phba, KERN_ERR, LOG_FIP,
-			"3061 Last IDX %d\n", last_index);
-		return 0; /* Empty rr list */
-	}
-	next_fcf_pri = 0;
-	/*
-	 * Clear the rr_bmask and set all of the bits that are at this
-	 * priority.
-	 */
-	memset(phba->fcf.fcf_rr_bmask, 0,
-			sizeof(*phba->fcf.fcf_rr_bmask));
-	spin_lock_irq(&phba->hbalock);
-	list_for_each_entry(fcf_pri, &phba->fcf.fcf_pri_list, list) {
-		if (fcf_pri->fcf_rec.flag & LPFC_FCF_FLOGI_FAILED)
-			continue;
-		/*
-		 * the 1st priority that has not FLOGI failed
-		 * will be the highest.
-		 */
-		if (!next_fcf_pri)
-			next_fcf_pri = fcf_pri->fcf_rec.priority;
-		spin_unlock_irq(&phba->hbalock);
-		if (fcf_pri->fcf_rec.priority == next_fcf_pri) {
-			rc = lpfc_sli4_fcf_rr_index_set(phba,
-						fcf_pri->fcf_rec.fcf_index);
-			if (rc)
-				return 0;
-		}
-		spin_lock_irq(&phba->hbalock);
-	}
-	/*
-	 * if next_fcf_pri was not set above and the list is not empty then
-	 * we have failed flogis on all of them. So reset flogi failed
-	 * and start at the begining.
-	 */
-	if (!next_fcf_pri && !list_empty(&phba->fcf.fcf_pri_list)) {
-		list_for_each_entry(fcf_pri, &phba->fcf.fcf_pri_list, list) {
-			fcf_pri->fcf_rec.flag &= ~LPFC_FCF_FLOGI_FAILED;
-			/*
-			 * the 1st priority that has not FLOGI failed
-			 * will be the highest.
-			 */
-			if (!next_fcf_pri)
-				next_fcf_pri = fcf_pri->fcf_rec.priority;
-			spin_unlock_irq(&phba->hbalock);
-			if (fcf_pri->fcf_rec.priority == next_fcf_pri) {
-				rc = lpfc_sli4_fcf_rr_index_set(phba,
-						fcf_pri->fcf_rec.fcf_index);
-				if (rc)
-					return 0;
-			}
-			spin_lock_irq(&phba->hbalock);
-		}
-	} else
-		ret = 1;
-	spin_unlock_irq(&phba->hbalock);
-
-	return ret;
-}
-/**
  * lpfc_sli4_fcf_rr_next_index_get - Get next eligible fcf record index
  * @phba: pointer to lpfc hba data structure.
  *
@@ -14708,7 +14438,6 @@
 	uint16_t next_fcf_index;
 
 	/* Search start from next bit of currently registered FCF index */
-next_priority:
 	next_fcf_index = (phba->fcf.current_rec.fcf_indx + 1) %
 					LPFC_SLI4_FCF_TBL_INDX_MAX;
 	next_fcf_index = find_next_bit(phba->fcf.fcf_rr_bmask,
@@ -14716,46 +14445,17 @@
 				       next_fcf_index);
 
 	/* Wrap around condition on phba->fcf.fcf_rr_bmask */
-	if (next_fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX) {
-		/*
-		 * If we have wrapped then we need to clear the bits that
-		 * have been tested so that we can detect when we should
-		 * change the priority level.
-		 */
+	if (next_fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX)
 		next_fcf_index = find_next_bit(phba->fcf.fcf_rr_bmask,
 					       LPFC_SLI4_FCF_TBL_INDX_MAX, 0);
-	}
-
 
 	/* Check roundrobin failover list empty condition */
-	if (next_fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX ||
-		next_fcf_index == phba->fcf.current_rec.fcf_indx) {
-		/*
-		 * If next fcf index is not found check if there are lower
-		 * Priority level fcf's in the fcf_priority list.
-		 * Set up the rr_bmask with all of the avaiable fcf bits
-		 * at that level and continue the selection process.
-		 */
-		if (lpfc_check_next_fcf_pri_level(phba))
-			goto next_priority;
+	if (next_fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX) {
 		lpfc_printf_log(phba, KERN_WARNING, LOG_FIP,
 				"2844 No roundrobin failover FCF available\n");
-		if (next_fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX)
-			return LPFC_FCOE_FCF_NEXT_NONE;
-		else {
-			lpfc_printf_log(phba, KERN_WARNING, LOG_FIP,
-				"3063 Only FCF available idx %d, flag %x\n",
-				next_fcf_index,
-			phba->fcf.fcf_pri[next_fcf_index].fcf_rec.flag);
-			return next_fcf_index;
-		}
+		return LPFC_FCOE_FCF_NEXT_NONE;
 	}
 
-	if (next_fcf_index < LPFC_SLI4_FCF_TBL_INDX_MAX &&
-		phba->fcf.fcf_pri[next_fcf_index].fcf_rec.flag &
-		LPFC_FCF_FLOGI_FAILED)
-		goto next_priority;
-
 	lpfc_printf_log(phba, KERN_INFO, LOG_FIP,
 			"2845 Get next roundrobin failover FCF (x%x)\n",
 			next_fcf_index);
@@ -14807,7 +14507,6 @@
 void
 lpfc_sli4_fcf_rr_index_clear(struct lpfc_hba *phba, uint16_t fcf_index)
 {
-	struct lpfc_fcf_pri *fcf_pri;
 	if (fcf_index >= LPFC_SLI4_FCF_TBL_INDX_MAX) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_FIP,
 				"2762 FCF (x%x) reached driver's book "
@@ -14816,14 +14515,6 @@
 		return;
 	}
 	/* Clear the eligible FCF record index bmask */
-	spin_lock_irq(&phba->hbalock);
-	list_for_each_entry(fcf_pri, &phba->fcf.fcf_pri_list, list) {
-		if (fcf_pri->fcf_rec.fcf_index == fcf_index) {
-			list_del_init(&fcf_pri->list);
-			break;
-		}
-	}
-	spin_unlock_irq(&phba->hbalock);
 	clear_bit(fcf_index, phba->fcf.fcf_rr_bmask);
 
 	lpfc_printf_log(phba, KERN_INFO, LOG_FIP,
