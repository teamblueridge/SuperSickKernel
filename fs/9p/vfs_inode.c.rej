--- fs/9p/vfs_inode.c
+++ fs/9p/vfs_inode.c
@@ -483,73 +420,47 @@
 	if (IS_ERR(st))
 		return ERR_CAST(st);
 
-	inode = v9fs_qid_iget(sb, &st->qid, st, new);
+	inode = v9fs_qid_iget(sb, &st->qid, st);
 	p9stat_free(st);
 	kfree(st);
 	return inode;
 }
 
 /**
- * v9fs_at_to_dotl_flags- convert Linux specific AT flags to
- * plan 9 AT flag.
- * @flags: flags to convert
- */
-static int v9fs_at_to_dotl_flags(int flags)
-{
-	int rflags = 0;
-	if (flags & AT_REMOVEDIR)
-		rflags |= P9_DOTL_AT_REMOVEDIR;
-	return rflags;
-}
-
-/**
  * v9fs_remove - helper function to remove files and directories
  * @dir: directory inode that is being deleted
- * @dentry:  dentry that is being deleted
+ * @file:  dentry that is being deleted
  * @rmdir: removing a directory
  *
  */
 
-static int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)
+static int v9fs_remove(struct inode *dir, struct dentry *file, int rmdir)
 {
-	struct inode *inode;
-	int retval = -EOPNOTSUPP;
-	struct p9_fid *v9fid, *dfid;
-	struct v9fs_session_info *v9ses;
+	int retval;
+	struct p9_fid *v9fid;
+	struct inode *file_inode;
+
+	P9_DPRINTK(P9_DEBUG_VFS, "inode: %p dentry: %p rmdir: %d\n", dir, file,
+		rmdir);
 
-	P9_DPRINTK(P9_DEBUG_VFS, "inode: %p dentry: %p rmdir: %x\n",
-		   dir, dentry, flags);
+	file_inode = file->d_inode;
+	v9fid = v9fs_fid_clone(file);
+	if (IS_ERR(v9fid))
+		return PTR_ERR(v9fid);
 
-	v9ses = v9fs_inode2v9ses(dir);
-	inode = dentry->d_inode;
-	dfid = v9fs_fid_lookup(dentry->d_parent);
-	if (IS_ERR(dfid)) {
-		retval = PTR_ERR(dfid);
-		P9_DPRINTK(P9_DEBUG_VFS, "fid lookup failed %d\n", retval);
-		return retval;
-	}
-	if (v9fs_proto_dotl(v9ses))
-		retval = p9_client_unlinkat(dfid, dentry->d_name.name,
-					    v9fs_at_to_dotl_flags(flags));
-	if (retval == -EOPNOTSUPP) {
-		/* Try the one based on path */
-		v9fid = v9fs_fid_clone(dentry);
-		if (IS_ERR(v9fid))
-			return PTR_ERR(v9fid);
-		retval = p9_client_remove(v9fid);
-	}
+	retval = p9_client_remove(v9fid);
 	if (!retval) {
 		/*
 		 * directories on unlink should have zero
 		 * link count
 		 */
-		if (flags & AT_REMOVEDIR) {
-			clear_nlink(inode);
+		if (rmdir) {
+			clear_nlink(file_inode);
 			drop_nlink(dir);
 		} else
-			drop_nlink(inode);
+			drop_nlink(file_inode);
 
-		v9fs_invalidate_inode_attr(inode);
+		v9fs_invalidate_inode_attr(file_inode);
 		v9fs_invalidate_inode_attr(dir);
 	}
 	return retval;
@@ -659,8 +572,8 @@
 	fid = NULL;
 	v9ses = v9fs_inode2v9ses(dir);
 	perm = unixmode2p9mode(v9ses, mode);
-	if (nd)
-		flags = nd->intent.open.flags;
+	if (nd && nd->flags & LOOKUP_OPEN)
+		flags = nd->intent.open.flags - 1;
 	else
 		flags = O_RDWR;
 
@@ -675,7 +588,7 @@
 
 	v9fs_invalidate_inode_attr(dir);
 	/* if we are opening a file, assign the open fid to the file */
-	if (nd) {
+	if (nd && nd->flags & LOOKUP_OPEN) {
 		v9inode = V9FS_I(dentry->d_inode);
 		mutex_lock(&v9inode->v_mutex);
 		if (v9ses->cache && !v9inode->writeback_fid &&
@@ -840,7 +739,7 @@
 
 int v9fs_vfs_rmdir(struct inode *i, struct dentry *d)
 {
-	return v9fs_remove(i, d, AT_REMOVEDIR);
+	return v9fs_remove(i, d, 1);
 }
 
 /**
@@ -888,12 +787,9 @@
 
 	down_write(&v9ses->rename_sem);
 	if (v9fs_proto_dotl(v9ses)) {
-		retval = p9_client_renameat(olddirfid, old_dentry->d_name.name,
-					    newdirfid, new_dentry->d_name.name);
-		if (retval == -EOPNOTSUPP)
-			retval = p9_client_rename(oldfid, newdirfid,
-						  new_dentry->d_name.name);
-		if (retval != -EOPNOTSUPP)
+		retval = p9_client_rename(oldfid, newdirfid,
+					(char *) new_dentry->d_name.name);
+		if (retval != -ENOSYS)
 			goto clunk_newdir;
 	}
 	if (old_dentry->d_parent != new_dentry->d_parent) {
@@ -918,6 +814,11 @@
 				clear_nlink(new_inode);
 			else
 				drop_nlink(new_inode);
+			/*
+			 * Work around vfs rename rehash bug with
+			 * FS_RENAME_DOES_D_MOVE
+			 */
+			v9fs_invalidate_inode_attr(new_inode);
 		}
 		if (S_ISDIR(old_inode->i_mode)) {
 			if (!new_inode)
