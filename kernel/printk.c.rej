--- kernel/printk.c
+++ kernel/printk.c
@@ -782,7 +780,7 @@
 static int console_trylock_for_printk(unsigned int cpu)
 	__releases(&logbuf_lock)
 {
-	int retval = 0, wake = 0;
+	int retval = 0;
 
 	if (console_trylock()) {
 		retval = 1;
@@ -795,14 +793,12 @@
 		 */
 		if (!can_use_console(cpu)) {
 			console_locked = 0;
-			wake = 1;
+			up(&console_sem);
 			retval = 0;
 		}
 	}
 	printk_cpu = UINT_MAX;
 	spin_unlock(&logbuf_lock);
-	if (wake)
-		up(&console_sem);
 	return retval;
 }
 static const char recursion_bug_msg [] =
@@ -1244,7 +1240,7 @@
 {
 	unsigned long flags;
 	unsigned _con_start, _log_end;
-	unsigned wake_klogd = 0, retry = 0;
+	unsigned wake_klogd = 0;
 
 	if (console_suspended) {
 		up(&console_sem);
@@ -1253,7 +1249,6 @@
 
 	console_may_schedule = 0;
 
-again:
 	for ( ; ; ) {
 		spin_lock_irqsave(&logbuf_lock, flags);
 		wake_klogd |= log_start - log_end;
@@ -1274,23 +1269,8 @@
 	if (unlikely(exclusive_console))
 		exclusive_console = NULL;
 
-	spin_unlock(&logbuf_lock);
-
 	up(&console_sem);
-
-	/*
-	 * Someone could have filled up the buffer again, so re-check if there's
-	 * something to flush. In case we cannot trylock the console_sem again,
-	 * there's a new owner and the console_unlock() from them will do the
-	 * flush, no worries.
-	 */
-	spin_lock(&logbuf_lock);
-	if (con_start != log_end)
-		retry = 1;
 	spin_unlock_irqrestore(&logbuf_lock, flags);
-	if (retry && console_trylock())
-		goto again;
-
 	if (wake_klogd)
 		wake_up_klogd();
 }
